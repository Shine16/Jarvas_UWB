{
    "docs": [
        {
            "location": "/",
            "text": "JARVAS Indoor Positioning System\n\n\n\n\nJARVAS (Just A Rather Very Average System) is an indoor positioning system, in which a wearable tag communicates with multiple stationary anchors to determine its position.\n\n\nHow to Build It\n\n\nOur primary documentatio for how to re-create our setup lives on \nInstructables\n.\n\n\nSource Files\n\n\nAll of our source files (including software, PCB design files, and MATLAB simulation code) live in our \nGitHub repository\n.\n\n\nTechnical Details\n\n\nThis website documents some of the more interesting technical aspects of the project. If you're looking to modify, extend, or get inspiration from what we did, read on.",
            "title": "Home"
        },
        {
            "location": "/#jarvas-indoor-positioning-system",
            "text": "JARVAS (Just A Rather Very Average System) is an indoor positioning system, in which a wearable tag communicates with multiple stationary anchors to determine its position.",
            "title": "JARVAS Indoor Positioning System"
        },
        {
            "location": "/#how-to-build-it",
            "text": "Our primary documentatio for how to re-create our setup lives on  Instructables .",
            "title": "How to Build It"
        },
        {
            "location": "/#source-files",
            "text": "All of our source files (including software, PCB design files, and MATLAB simulation code) live in our  GitHub repository .",
            "title": "Source Files"
        },
        {
            "location": "/#technical-details",
            "text": "This website documents some of the more interesting technical aspects of the project. If you're looking to modify, extend, or get inspiration from what we did, read on.",
            "title": "Technical Details"
        },
        {
            "location": "/hardware/",
            "text": "JARVAS Hardware\n\n\n\n\nThe core of the JARVAS system is the DWM1000 (\n\nproduct page\n,\n\ndatasheet\n\n) radio module, an ultra wideband transciever module optimized for time of\nflight ranging systems, and the Atmega32U4 processor.\n\n\nThere are two versions of the JARVAS hardware: a base station board that\nsupports WiFi (using an\n\nESP8266\n\n) and is designed for easy debugging, and a small, low-cost tag module.\nThe system requires at least one of the anchors have WiFi support so transmit\nlocation data to a server, however all other anchors and tags in the system\nmay use either the larger base station board or the small tag board.\n\n\nThe Tag\n\n\n\n\nThe tag board hosts an Atmega32U4, a single-cell LiPo/Li-Ion connector, a few\ndebugging LEDs, and the DWM1000 radio module. It is essentially a\npurpose-built version of the popular \nSparkFun Pro Micro\n\nor the \nAdafruit Atmega32U4 breakout\n\nwith a DWM1000 module built in.\n\n\nIn total, it measures 1.5\"x0.9\" without the programming tag.\n\n\nNote that while we call this this \"tag\", it is completely capable of being\nused as an anchor as well, provided that there is at least one anchor in the\nsystem which supports WiFi.\n\n\nProgramming Header\n\n\n\n\nThe tag comes with a break-away section for initial programming. The\nsection at the top contains test points for the 3.3 V and GND rails and an\nICSP header. This ICSP header can be used to program the Atmega32U4. If you\nchoose to install the Arduino firmware, as described \nhere\n,\nyou can program this board directly over USB through the Arduino software.\nOnce you verify that everythings is working, this top section can be broken\noff to reduce the size and height of the PCB.\n\n\n\n\nThe Anchor\n\n\n\n\nThe anchor is the larger, more debug-friendly, and WiFi-supporting version.\nIt is extremely similar to the tag except for the addition of an ESP8266 WiFi\nModule and using an off-the-shelf Arduino Pro Micro instead of having an\nAtmega32U4 on-board. This means that no programmer is required to get this\nboard up and running. The downside, though, is that it is significantly larger\nand costs more.",
            "title": "Hardware"
        },
        {
            "location": "/hardware/#jarvas-hardware",
            "text": "The core of the JARVAS system is the DWM1000 ( product page , datasheet \n) radio module, an ultra wideband transciever module optimized for time of\nflight ranging systems, and the Atmega32U4 processor.  There are two versions of the JARVAS hardware: a base station board that\nsupports WiFi (using an ESP8266 \n) and is designed for easy debugging, and a small, low-cost tag module.\nThe system requires at least one of the anchors have WiFi support so transmit\nlocation data to a server, however all other anchors and tags in the system\nmay use either the larger base station board or the small tag board.",
            "title": "JARVAS Hardware"
        },
        {
            "location": "/hardware/#the-tag",
            "text": "The tag board hosts an Atmega32U4, a single-cell LiPo/Li-Ion connector, a few\ndebugging LEDs, and the DWM1000 radio module. It is essentially a\npurpose-built version of the popular  SparkFun Pro Micro \nor the  Adafruit Atmega32U4 breakout \nwith a DWM1000 module built in.  In total, it measures 1.5\"x0.9\" without the programming tag.  Note that while we call this this \"tag\", it is completely capable of being\nused as an anchor as well, provided that there is at least one anchor in the\nsystem which supports WiFi.  Programming Header   The tag comes with a break-away section for initial programming. The\nsection at the top contains test points for the 3.3 V and GND rails and an\nICSP header. This ICSP header can be used to program the Atmega32U4. If you\nchoose to install the Arduino firmware, as described  here ,\nyou can program this board directly over USB through the Arduino software.\nOnce you verify that everythings is working, this top section can be broken\noff to reduce the size and height of the PCB.",
            "title": "The Tag"
        },
        {
            "location": "/hardware/#the-anchor",
            "text": "The anchor is the larger, more debug-friendly, and WiFi-supporting version.\nIt is extremely similar to the tag except for the addition of an ESP8266 WiFi\nModule and using an off-the-shelf Arduino Pro Micro instead of having an\nAtmega32U4 on-board. This means that no programmer is required to get this\nboard up and running. The downside, though, is that it is significantly larger\nand costs more.",
            "title": "The Anchor"
        },
        {
            "location": "/firmware/",
            "text": "Programming Arduino Firmware on an Atmega32U4\n\n\nThis page is not really specific to this project and should be useful to anyone trying to program Arduino firmware onto an \nAtmega32U4\n chip.\n\n\nWhat you'll need\n\n\nYou will need:\n\n\n\n\nAn ICSP programmer (such as the \nJTAGICE3\n)\n\n\nThe \navrdude\n software\n\n\nFirmware for the chip. We used SparkFun's \nCaterina\n bootloader (Caterina-promicro8.bin from \nhere\n)\n\n\nA board with an Atmega32U4 and an ICSP header, such as our \nTag Board\n\n\n\n\nTip for Linux users\n\n\nYou may need to setup port permission for your programmer. For the JTAGICE3, you'll need to create a \n/etc/udev/rules.d/98-local-jtagice3.rules\n file with the following line:\n\n\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"03eb\", ATTRS{idProduct}==\"2140\", GROUP=\"dialout\"\n\n\n\n\nAlso, be sure your user is in the \ndialout\n group.\n\n\nInstructions\n\n\n\n\nStep 1: Hook up your programmer\n\n\nConnect your programmer to the ICSP header on your board. Double check the pinouts and orientations (many ICSP connectors are not keyed) before powering things up.\n\n\nRemember that your programmer generally does not supply power to the board, so you'll need to supply that yourself.\n\n\nStep 2: Test the connection\n\n\nThe following command will read the three sets of fuse bits from the microcontroller and write the values to three text files on your system:\n\n\navrdude -v -pm32u4 -cjtag3isp -Pusb -B22 -U efuse:r:efuse.hex:h -U hfuse:r:hfuse.hex:h -U lfuse:r:lfuse.hex:h\n\n\n\n\nYou should get some output that ends with:\n\n\navrdude: safemode: hfuse reads as 99\navrdude: safemode: efuse reads as F3\navrdude: safemode: Fuses OK (E:F3, H:99, L:5E)\n\navrdude done.  Thank you.\n\n\n\n\nStep 3: Programming\n\n\nWith the firmware file placed in your working directory, run the following command to set the fuse bits and program your chip:\n\n\navrdude -v -pm32u4 -cjtag3isp -Pusb -B22 -U flash:w:Caterina-promicro8.hex -U hfuse:w:0xd8:m -U lfuse:w:0xff:m -U efuse:w:0xfe:m\n\n\n\n\nIt may fail to write the efuse. If prompted, answer 'y' to retry. If it fails, don't worry.\n\n\nStep 4: Try it!\n\n\nPlug your board into your computer over USB and program it with the Arduino software.\n\n\nNotes and References\n\n\nThe above commands assume you're using a JTAGICE3 programmer to program an Atmega32U4 clocekd at 8 MHz with a 3.3V supply voltage. If any of those things are not quite the same for you, you'll have to adjust things a bit.\n\n\nYou can find fuse bit settings that go along with the various SparkFun firmwares on \ntheir repository\n.\n\n\nUseful References\n\n\n\n\nFuse bit calculator\n\n\nJTAGICE3 Pinout\n\n\nAVRDUDE Refernce\n\n\nA \nblog post\n from someone else who has done this",
            "title": "Installing Arduino Firmware"
        },
        {
            "location": "/firmware/#programming-arduino-firmware-on-an-atmega32u4",
            "text": "This page is not really specific to this project and should be useful to anyone trying to program Arduino firmware onto an  Atmega32U4  chip.",
            "title": "Programming Arduino Firmware on an Atmega32U4"
        },
        {
            "location": "/firmware/#what-youll-need",
            "text": "You will need:   An ICSP programmer (such as the  JTAGICE3 )  The  avrdude  software  Firmware for the chip. We used SparkFun's  Caterina  bootloader (Caterina-promicro8.bin from  here )  A board with an Atmega32U4 and an ICSP header, such as our  Tag Board   Tip for Linux users  You may need to setup port permission for your programmer. For the JTAGICE3, you'll need to create a  /etc/udev/rules.d/98-local-jtagice3.rules  file with the following line:  SUBSYSTEM==\"usb\", ATTRS{idVendor}==\"03eb\", ATTRS{idProduct}==\"2140\", GROUP=\"dialout\"  Also, be sure your user is in the  dialout  group.",
            "title": "What you'll need"
        },
        {
            "location": "/firmware/#instructions",
            "text": "Step 1: Hook up your programmer  Connect your programmer to the ICSP header on your board. Double check the pinouts and orientations (many ICSP connectors are not keyed) before powering things up.  Remember that your programmer generally does not supply power to the board, so you'll need to supply that yourself.  Step 2: Test the connection  The following command will read the three sets of fuse bits from the microcontroller and write the values to three text files on your system:  avrdude -v -pm32u4 -cjtag3isp -Pusb -B22 -U efuse:r:efuse.hex:h -U hfuse:r:hfuse.hex:h -U lfuse:r:lfuse.hex:h  You should get some output that ends with:  avrdude: safemode: hfuse reads as 99\navrdude: safemode: efuse reads as F3\navrdude: safemode: Fuses OK (E:F3, H:99, L:5E)\n\navrdude done.  Thank you.  Step 3: Programming  With the firmware file placed in your working directory, run the following command to set the fuse bits and program your chip:  avrdude -v -pm32u4 -cjtag3isp -Pusb -B22 -U flash:w:Caterina-promicro8.hex -U hfuse:w:0xd8:m -U lfuse:w:0xff:m -U efuse:w:0xfe:m  It may fail to write the efuse. If prompted, answer 'y' to retry. If it fails, don't worry.  Step 4: Try it!  Plug your board into your computer over USB and program it with the Arduino software.",
            "title": "Instructions"
        },
        {
            "location": "/firmware/#notes-and-references",
            "text": "The above commands assume you're using a JTAGICE3 programmer to program an Atmega32U4 clocekd at 8 MHz with a 3.3V supply voltage. If any of those things are not quite the same for you, you'll have to adjust things a bit.  You can find fuse bit settings that go along with the various SparkFun firmwares on  their repository .  Useful References   Fuse bit calculator  JTAGICE3 Pinout  AVRDUDE Refernce  A  blog post  from someone else who has done this",
            "title": "Notes and References"
        },
        {
            "location": "/localization/",
            "text": "Localization\n\n\nJARVAS estimates your position using a linear least squares algorithm based\non time of flight ranging data. On this page, we will break down how this\nworks in detail.\n\n\nImagine you are on a ship and can see a single lighthouse in the distance. \nLet's say you can tell the distance to this lighthouse but nothing else.\nIf you were looking at a map and knew the location of the lighthouse, you\ncould draw a circle around the lighthouse and know that you were somewhere\nalong the circle.\n\n\nNow let's say you can see a second lighthouse and also your know distance to \nit (but not, let's pretend, the angle between the two lighthouses). Now you\nhave two circles you can draw. Assuming the two lighthouses are in different\nlocations, the circles will overlap in one or two locations. Finally, by\nadding a third lighthouse, you can figure out which point you are at.\n\n\n\n\nDerived from image by pixelbuddha [CC BY 3.0 (http://creativecommons.org/licenses/by/3.0)], via Wikimedia Commons\n\n\nLinear Least Squares Estimation\n\n\nIf you aren't familiar with linear least squares estimation, we recommend some\nbackground reading before jumping into this:\n\n\nWikipedia: Linear Least Squares\n\n\nStanford Linear Algebra Course Notes\n\n\nOur linearized technique is based on the first method described in \n\"Linear least squares localization in sensor networks\" by Yue Wang (DOI: \n\n10.1186/s13638-015-0298-1\n).\n\n\nIn general, localization based on a set of distances in a non-linear problem,\nhowever there are linear approximtaions that work quite well.\n\n\nEach anchor has some known position \n(x_i,y_i\n and is can measure a distance\n\n\\hat{d_i}\n to the tag. For a single anchor \ni\n ranging to a tag at\nposition \n(x,y)\n, this\ngives us the simple geometric equation:\n\n\n\n\n (x-x_i)^2+(y-y_i)^2=d_i^2 \n\n\n\n\nWe can then re-arrange this expression as follows:\n\n\n\n\n x^2-2xx_i+x_i^2+y^2-2yy_i+y_i^2=\\hat{d}_i^2 \\\\\n-2xx_i - 2yy_i + (x^2+y^2) = \\hat{d}_i^2 - x_i^2 - y_i^2 \n\n\n\n\nWe have three (or more) anchors, so we can write at least three of these\nequations. Written in matrix form, we have:\n\n\n\n\n\n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}\n\n\n\n\n\nThis gives us the standard form:\n\n\n\n\n\n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}_{ls}\n=\n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}^\\dagger\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}\n\n\n\n\n\nThe left side of the equation is what we want to solve for. Specifically, we are interested in the first two terms of the vector: \nx\n and \ny\n.\n\n\nOn the right, the large matrix that we have to take the \n\npseudo-inverse\n\nof is a function only of the configuration of the system. It changes only if the anchors move, not if the tag moves. This is very important because taking the pseudo-inverse requires a non-trivial number of computations, especially as you start adding more anchors.\n\n\nAt runtime, this works out to be a single matrix-vector multiplication of a 3x3 by a 3x1.\n\n\nMATLAB Implementation\n\n\n\n\nIn order to test this algorith, we created a MATLAB script that takes in a set of positions and ranges and outputs a graph of the real and estimated location of the tag. If you are intersted in extending this project to use any of several possible better linearized algorithms, this MATLAB script would be a good starting point.\n\n\nYou can find the two MATLAB files \nrangepositioning.m\n and \nplotposition.m\n in the \nsimulation folder\n of our repository.\n\n\nC Implementation\n\n\nIn the JARVAS system, this processing is run on the tag iself. The C implementaiton of this algorithm uses the Arduino MatrixMath library and lives in the \ntag sketch\n.",
            "title": "Localization Algorithm"
        },
        {
            "location": "/localization/#localization",
            "text": "JARVAS estimates your position using a linear least squares algorithm based\non time of flight ranging data. On this page, we will break down how this\nworks in detail.  Imagine you are on a ship and can see a single lighthouse in the distance. \nLet's say you can tell the distance to this lighthouse but nothing else.\nIf you were looking at a map and knew the location of the lighthouse, you\ncould draw a circle around the lighthouse and know that you were somewhere\nalong the circle.  Now let's say you can see a second lighthouse and also your know distance to \nit (but not, let's pretend, the angle between the two lighthouses). Now you\nhave two circles you can draw. Assuming the two lighthouses are in different\nlocations, the circles will overlap in one or two locations. Finally, by\nadding a third lighthouse, you can figure out which point you are at.   Derived from image by pixelbuddha [CC BY 3.0 (http://creativecommons.org/licenses/by/3.0)], via Wikimedia Commons",
            "title": "Localization"
        },
        {
            "location": "/localization/#linear-least-squares-estimation",
            "text": "If you aren't familiar with linear least squares estimation, we recommend some\nbackground reading before jumping into this:  Wikipedia: Linear Least Squares  Stanford Linear Algebra Course Notes  Our linearized technique is based on the first method described in \n\"Linear least squares localization in sensor networks\" by Yue Wang (DOI:  10.1186/s13638-015-0298-1 ).  In general, localization based on a set of distances in a non-linear problem,\nhowever there are linear approximtaions that work quite well.  Each anchor has some known position  (x_i,y_i  and is can measure a distance \\hat{d_i}  to the tag. For a single anchor  i  ranging to a tag at\nposition  (x,y) , this\ngives us the simple geometric equation:    (x-x_i)^2+(y-y_i)^2=d_i^2    We can then re-arrange this expression as follows:    x^2-2xx_i+x_i^2+y^2-2yy_i+y_i^2=\\hat{d}_i^2 \\\\\n-2xx_i - 2yy_i + (x^2+y^2) = \\hat{d}_i^2 - x_i^2 - y_i^2    We have three (or more) anchors, so we can write at least three of these\nequations. Written in matrix form, we have:   \n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}   This gives us the standard form:   \n\\begin{bmatrix}\nx \\\\\ny \\\\\nx^2 + y^2\n\\end{bmatrix}_{ls}\n=\n\\begin{bmatrix}\n-2x_1 & -2y_1 & 1 \\\\\n-2x_2 & -2y_2 & 1 \\\\\n-2x_3 & -2y_3 & 1\n\\end{bmatrix}^\\dagger\n\\begin{bmatrix}\n\\hat{d}_1^2-x_1^2-y_1^2 \\\\\n\\hat{d}_2^2-x_2^2-y_2^2 \\\\\n\\hat{d}_3^2-x_3^2-y_3^2\n\\end{bmatrix}   The left side of the equation is what we want to solve for. Specifically, we are interested in the first two terms of the vector:  x  and  y .  On the right, the large matrix that we have to take the  pseudo-inverse \nof is a function only of the configuration of the system. It changes only if the anchors move, not if the tag moves. This is very important because taking the pseudo-inverse requires a non-trivial number of computations, especially as you start adding more anchors.  At runtime, this works out to be a single matrix-vector multiplication of a 3x3 by a 3x1.",
            "title": "Linear Least Squares Estimation"
        },
        {
            "location": "/localization/#matlab-implementation",
            "text": "In order to test this algorith, we created a MATLAB script that takes in a set of positions and ranges and outputs a graph of the real and estimated location of the tag. If you are intersted in extending this project to use any of several possible better linearized algorithms, this MATLAB script would be a good starting point.  You can find the two MATLAB files  rangepositioning.m  and  plotposition.m  in the  simulation folder  of our repository.",
            "title": "MATLAB Implementation"
        },
        {
            "location": "/localization/#c-implementation",
            "text": "In the JARVAS system, this processing is run on the tag iself. The C implementaiton of this algorithm uses the Arduino MatrixMath library and lives in the  tag sketch .",
            "title": "C Implementation"
        },
        {
            "location": "/filtering/",
            "text": "Filtering\n\n\nIn our testing, we found the ranging data to be quite noisy. With only three anchors, the linear least squares algorithm is quite noise sensitive. As such, some filtering on the ranging data is necessary.\n\n\nThe \nArduino DWM1000 library\n by thotro has a built-in (exponential moving average](https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average) filter that can be enabled with a single call to \nDW1000Ranging.useRangeFilter(true);\n. This is a very computationally low-cost choice and definitely a good place to start.\n\n\nEarly on, we took some raw data from pairs of DWM1000 modules in various locations. An example of this data is below:\n\n\n\n\nAs you can see, the noise is dominated by sharp peaks lasting only a sample or two. For this type of noise, a median filter is often a more effective choice. While any kind of moving average filter is always going to be affected at least a little by an extremely out of range value, a median filter will allow such valus to slide through without changing output.\n\n\nShown below are the results of a simple median filter overlayed in red against another raw data set in black.\n\n\n \"Median filtered data\")",
            "title": "Filtering"
        },
        {
            "location": "/filtering/#filtering",
            "text": "In our testing, we found the ranging data to be quite noisy. With only three anchors, the linear least squares algorithm is quite noise sensitive. As such, some filtering on the ranging data is necessary.  The  Arduino DWM1000 library  by thotro has a built-in (exponential moving average](https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average) filter that can be enabled with a single call to  DW1000Ranging.useRangeFilter(true); . This is a very computationally low-cost choice and definitely a good place to start.  Early on, we took some raw data from pairs of DWM1000 modules in various locations. An example of this data is below:   As you can see, the noise is dominated by sharp peaks lasting only a sample or two. For this type of noise, a median filter is often a more effective choice. While any kind of moving average filter is always going to be affected at least a little by an extremely out of range value, a median filter will allow such valus to slide through without changing output.  Shown below are the results of a simple median filter overlayed in red against another raw data set in black.   \"Median filtered data\")",
            "title": "Filtering"
        }
    ]
}